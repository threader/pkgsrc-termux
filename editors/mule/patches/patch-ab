$NetBSD: patch-ab,v 1.4 2017/04/29 01:11:55 tsutsui Exp $

Pull unexelf.c from newer emacs.

--- src/unexelf.c.orig	1994-10-21 04:21:00.000000000 +0000
+++ src/unexelf.c
@@ -1,19 +1,22 @@
-/* Copyright (C) 1985, 1986, 1987, 1988, 1990, 1992
+/* Copyright (C) 1985, 1986, 1987, 1988, 1990, 1992, 1999, 2000, 01, 02
    Free Software Foundation, Inc.
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2, or (at your option)
-    any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+This file is part of GNU Emacs.
+
+GNU Emacs is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Emacs is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Emacs; see the file COPYING.  If not, write to
+the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.
 
 In other words, you are welcome to use, share and improve this program.
 You are forbidden to forbid anyone else to use, share and improve
@@ -30,14 +33,14 @@ what you give them.   Help stamp out sof
  * Modified heavily since then.
  *
  * Synopsis:
- *	unexec (new_name, a_name, data_start, bss_start, entry_address)
- *	char *new_name, *a_name;
+ *	unexec (new_name, old_name, data_start, bss_start, entry_address)
+ *	char *new_name, *old_name;
  *	unsigned data_start, bss_start, entry_address;
  *
  * Takes a snapshot of the program and makes an a.out format file in the
  * file named by the string argument new_name.
- * If a_name is non-NULL, the symbol table will be taken from the given file.
- * On some machines, an existing a_name file is required.
+ * If old_name is non-NULL, the symbol table will be taken from the given file.
+ * On some machines, an existing old_name file is required.
  *
  * The boundaries within the a.out file may be adjusted with the data_start
  * and bss_start arguments.  Either or both may be given as 0 for defaults.
@@ -49,11 +52,6 @@ what you give them.   Help stamp out sof
  * The value you specify may be rounded down to a suitable boundary
  * as required by the machine you are using.
  *
- * Specifying zero for data_start means the boundary between text and data
- * should not be the same as when the program was loaded.
- * If NO_REMAP is defined, the argument data_start is ignored and the
- * segment boundaries are never changed.
- *
  * Bss_start indicates how much of the data segment is to be saved in the
  * a.out file and restored when the program is executed.  It gives the lowest
  * unsaved address, and is rounded up to a page boundary.  The default when 0
@@ -63,9 +61,6 @@ what you give them.   Help stamp out sof
  *
  * The new file is set up to start at entry_address.
  *
- * If you make improvements I'd like to get them too.
- * harpo!utah-cs!thomas, thomas@Utah-20
- *
  */
 
 /* Even more heavily modified by james@bigtex.cactus.org of Dell Computer Co.
@@ -315,25 +310,25 @@ Filesz      Memsz       Flags       Alig
 
 
  */
-
-/* Modified by wtien@urbana.mcd.mot.com of Motorola Inc. 
- * 
+
+/* Modified by wtien@urbana.mcd.mot.com of Motorola Inc.
+ *
  * The above mechanism does not work if the unexeced ELF file is being
- * re-layout by other applications (such as `strip'). All the applications 
+ * re-layout by other applications (such as `strip'). All the applications
  * that re-layout the internal of ELF will layout all sections in ascending
- * order of their file offsets. After the re-layout, the data2 section will 
- * still be the LAST section in the section header vector, but its file offset 
+ * order of their file offsets. After the re-layout, the data2 section will
+ * still be the LAST section in the section header vector, but its file offset
  * is now being pushed far away down, and causes part of it not to be mapped
- * in (ie. not covered by the load segment entry in PHDR vector), therefore 
+ * in (ie. not covered by the load segment entry in PHDR vector), therefore
  * causes the new binary to fail.
  *
  * The solution is to modify the unexec algorithm to insert the new data2
  * section header right before the new bss section header, so their file
- * offsets will be in the ascending order. Since some of the section's (all 
- * sections AFTER the bss section) indexes are now changed, we also need to 
- * modify some fields to make them point to the right sections. This is done 
+ * offsets will be in the ascending order. Since some of the section's (all
+ * sections AFTER the bss section) indexes are now changed, we also need to
+ * modify some fields to make them point to the right sections. This is done
  * by macro PATCH_INDEX. All the fields that need to be patched are:
- * 
+ *
  * 1. ELF header e_shstrndx field.
  * 2. section header sh_link and sh_info field.
  * 3. symbol table entry st_shndx field.
@@ -345,85 +340,214 @@ Filesz      Memsz       Flags       Alig
         Link    Info    Adralgn      Entsize
 
 [1]     1       2       0x80480d4    0xd4         0x13          .interp
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [2]     5       2       0x80480e8    0xe8         0x388         .hash
-        3       0       0x4          0x4          
+        3       0       0x4          0x4
 
 [3]     11      2       0x8048470    0x470        0x7f0         .dynsym
-        4       1       0x4          0x10         
+        4       1       0x4          0x10
 
 [4]     3       2       0x8048c60    0xc60        0x3ad         .dynstr
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [5]     9       2       0x8049010    0x1010       0x338         .rel.plt
-        3       7       0x4          0x8          
+        3       7       0x4          0x8
 
 [6]     1       6       0x8049348    0x1348       0x3           .init
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [7]     1       6       0x804934c    0x134c       0x680         .plt
-        0       0       0x4          0x4          
+        0       0       0x4          0x4
 
 [8]     1       6       0x80499cc    0x19cc       0x3c56f       .text
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [9]     1       6       0x8085f3c    0x3df3c      0x3           .fini
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [10]    1       2       0x8085f40    0x3df40      0x69c         .rodata
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [11]    1       2       0x80865dc    0x3e5dc      0xd51         .rodata1
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [12]    1       3       0x8088330    0x3f330      0x20afc       .data
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [13]    1       3       0x80a8e2c    0x5fe2c      0x89d         .data1
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [14]    1       3       0x80a96cc    0x606cc      0x1a8         .got
-        0       0       0x4          0x4          
+        0       0       0x4          0x4
 
 [15]    6       3       0x80a9874    0x60874      0x80          .dynamic
-        4       0       0x4          0x8          
+        4       0       0x4          0x8
 
 [16]    1       3       0x80a98f4    0x608f4      0x1cf0c       .data
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [17]    8       3       0x80c6800    0x7d800      0             .bss
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [18]    2       0       0            0x7d800      0x9b90        .symtab
-        19      371     0x4          0x10         
+        19      371     0x4          0x10
 
 [19]    3       0       0            0x87390      0x8526        .strtab
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [20]    3       0       0            0x8f8b6      0x93          .shstrtab
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [21]    1       0       0            0x8f949      0x68b7        .comment
-        0       0       0x1          0            
+        0       0       0x1          0
 
  */
 
+/*
+ * Modified by rdh@yottayotta.com of Yotta Yotta Incorporated.
+ * 
+ * The code originally used mmap() to create a memory image of the new
+ * and old object files.  This had a few handy features: (1) you get
+ * to use a cool system call like mmap, (2) no need to explicitly
+ * write out the new file before the close, and (3) no swap space
+ * requirements.  Unfortunately, mmap() often fails to work with
+ * nfs-mounted file systems.
+ *
+ * So, instead of relying on the vm subsystem to do the file i/o for
+ * us, it's now done explicitly.  A buffer of the right size for the
+ * file is dynamically allocated, and either the old_name is read into
+ * it, or it is initialized with the correct new executable contents,
+ * and then written to new_name.
+ */
+
+#ifndef emacs
+#define fatal(a, b, c) fprintf (stderr, a, b, c), exit (1)
+#include <string.h>
+#else
+#include "config.h"
+#endif
+
 #include <sys/types.h>
 #include <stdio.h>
 #include <sys/stat.h>
 #include <memory.h>
-#include <string.h>
 #include <errno.h>
 #include <unistd.h>
 #include <fcntl.h>
+#if !defined (__NetBSD__) && !defined (__OpenBSD__)
 #include <elf.h>
+#endif
 #include <sys/mman.h>
-
-#ifndef emacs
-#define fatal(a, b, c) fprintf (stderr, a, b, c), exit (1)
+#if defined (__sony_news) && defined (_SYSTYPE_SYSV)
+#include <sys/elf_mips.h>
+#include <sym.h>
+#endif /* __sony_news && _SYSTYPE_SYSV */
+#if __sgi
+#include <syms.h> /* for HDRR declaration */
+#endif /* __sgi */
+
+#ifndef MAP_ANON
+#ifdef MAP_ANONYMOUS
+#define MAP_ANON MAP_ANONYMOUS
 #else
-extern void fatal (char *, ...);
+#define MAP_ANON 0
+#endif
+#endif
+
+#ifdef MCPATH			/* hir, 1993.8.4 */
+#undef open
+#undef chmod
+#endif  
+
+#ifndef MAP_FAILED
+#define MAP_FAILED ((void *) -1)
+#endif
+
+#if defined (__alpha__) && !defined (__NetBSD__) && !defined (__OpenBSD__)
+/* Declare COFF debugging symbol table.  This used to be in
+   /usr/include/sym.h, but this file is no longer included in Red Hat
+   5.0 and presumably in any other glibc 2.x based distribution.  */
+typedef struct {
+	short magic;
+	short vstamp;
+	int ilineMax;
+	int idnMax;
+	int ipdMax;
+	int isymMax;
+	int ioptMax;
+	int iauxMax;
+	int issMax;
+	int issExtMax;
+	int ifdMax;
+	int crfd;
+	int iextMax;
+	long cbLine;
+	long cbLineOffset;
+	long cbDnOffset;
+	long cbPdOffset;
+	long cbSymOffset;
+	long cbOptOffset;
+	long cbAuxOffset;
+	long cbSsOffset;
+	long cbSsExtOffset;
+	long cbFdOffset;
+	long cbRfdOffset;
+	long cbExtOffset;
+} HDRR, *pHDRR; 
+#define cbHDRR sizeof(HDRR)
+#define hdrNil ((pHDRR)0)
+#endif
+
+#ifdef __NetBSD__
+/*
+ * NetBSD does not have normal-looking user-land ELF support.
+ */
+# include <sys/exec_elf.h>
+
+# ifndef PT_LOAD
+#  define PT_LOAD	Elf_pt_load
+#  if 0						/* was in pkgsrc patches for 20.7 */
+#   define SHT_PROGBITS Elf_sht_progbits
+#  endif
+#  define SHT_SYMTAB	Elf_sht_symtab
+#  define SHT_DYNSYM	Elf_sht_dynsym
+#  define SHT_NULL	Elf_sht_null
+#  define SHT_NOBITS	Elf_sht_nobits
+#  define SHT_REL	Elf_sht_rel
+#  define SHT_RELA	Elf_sht_rela
+
+#  define SHN_UNDEF	Elf_eshn_undefined
+#  define SHN_ABS	Elf_eshn_absolute
+#  define SHN_COMMON	Elf_eshn_common
+# endif /* !PT_LOAD */
+
+#endif /* __NetBSD__ */
+
+#ifdef __OpenBSD__
+# include <sys/exec_elf.h>
+#endif
+
+#if __GNU_LIBRARY__ - 0 >= 6
+# include <link.h>	/* get ElfW etc */
+#endif
+
+#ifndef ElfW
+# ifdef __STDC__
+#  define ElfBitsW(bits, type) Elf##bits##_##type
+# else
+#  define ElfBitsW(bits, type) Elf/**/bits/**/_/**/type
+# endif
+# ifndef ELFSIZE
+#  ifdef _LP64
+#   define ELFSIZE 64
+#  else
+#   define ELFSIZE 32
+#  endif
+# endif
+  /* This macro expands `bits' before invoking ElfBitsW.  */
+# define ElfExpandBitsW(bits, type) ElfBitsW (bits, type)
+# define ElfW(type) ElfExpandBitsW (ELFSIZE, type)
 #endif
 
 #ifndef ELF_BSS_SECTION_NAME
@@ -433,15 +557,38 @@ extern void fatal (char *, ...);
 /* Get the address of a particular section or program header entry,
  * accounting for the size of the entries.
  */
+/*
+   On PPC Reference Platform running Solaris 2.5.1
+   the plt section is also of type NOBI like the bss section.
+   (not really stored) and therefore sections after the bss
+   section start at the plt offset. The plt section is always
+   the one just before the bss section.
+   Thus, we modify the test from
+      if (NEW_SECTION_H (nn).sh_offset >= new_data2_offset)
+   to
+      if (NEW_SECTION_H (nn).sh_offset >=
+               OLD_SECTION_H (old_bss_index-1).sh_offset)
+   This is just a hack. We should put the new data section
+   before the .plt section.
+   And we should not have this routine at all but use
+   the libelf library to read the old file and create the new
+   file.
+   The changed code is minimal and depends on prep set in m/prep.h
+   Erik Deumens
+   Quantum Theory Project
+   University of Florida
+   deumens@qtp.ufl.edu
+   Apr 23, 1996
+   */
 
 #define OLD_SECTION_H(n) \
-     (*(Elf32_Shdr *) ((byte *) old_section_h + old_file_h->e_shentsize * (n)))
+     (*(ElfW(Shdr) *) ((byte *) old_section_h + old_file_h->e_shentsize * (n)))
 #define NEW_SECTION_H(n) \
-     (*(Elf32_Shdr *) ((byte *) new_section_h + new_file_h->e_shentsize * (n)))
+     (*(ElfW(Shdr) *) ((byte *) new_section_h + new_file_h->e_shentsize * (n)))
 #define OLD_PROGRAM_H(n) \
-     (*(Elf32_Phdr *) ((byte *) old_program_h + old_file_h->e_phentsize * (n)))
+     (*(ElfW(Phdr) *) ((byte *) old_program_h + old_file_h->e_phentsize * (n)))
 #define NEW_PROGRAM_H(n) \
-     (*(Elf32_Phdr *) ((byte *) new_program_h + new_file_h->e_phentsize * (n)))
+     (*(ElfW(Phdr) *) ((byte *) new_program_h + new_file_h->e_phentsize * (n)))
 
 #define PATCH_INDEX(n) \
   do { \
@@ -451,9 +598,8 @@ typedef unsigned char byte;
 
 /* Round X up to a multiple of Y.  */
 
-int
-round_up (x, y)
-     int x, y;
+static ElfW(Addr)
+round_up (ElfW(Addr) x, ElfW(Addr) y)
 {
   int rem = x % y;
   if (rem == 0)
@@ -461,6 +607,39 @@ round_up (x, y)
   return x - rem + y;
 }
 
+/* Return the index of the section named NAME.
+   SECTION_NAMES, FILE_NAME and FILE_H give information
+   about the file we are looking in.
+
+   If we don't find the section NAME, that is a fatal error
+   if NOERROR is 0; we return -1 if NOERROR is nonzero.  */
+
+static int
+find_section (char *name, char *section_names, char *file_name, ElfW(Ehdr) *old_file_h, ElfW(Shdr) *old_section_h, int noerror)
+{
+  int idx;
+
+  for (idx = 1; idx < old_file_h->e_shnum; idx++)
+    {
+#ifdef DEBUG
+      fprintf (stderr, "Looking for %s - found %s\n", name,
+	       section_names + OLD_SECTION_H (idx).sh_name);
+#endif
+      if (!strcmp (section_names + OLD_SECTION_H (idx).sh_name,
+		   name))
+	break;
+    }
+  if (idx == old_file_h->e_shnum)
+    {
+      if (noerror)
+	return -1;
+      else
+	fatal ("Can't find %s in %s.\n", name, file_name);
+    }
+
+  return idx;
+}
+
 /* ****************************************************************
  * unexec
  *
@@ -471,34 +650,45 @@ round_up (x, y)
  *
  */
 void
-unexec (new_name, old_name, data_start, bss_start, entry_address)
-     char *new_name, *old_name;
-     unsigned data_start, bss_start, entry_address;
+unexec (char *new_name, char *old_name, unsigned data_start, unsigned bss_start, unsigned entry_address)
 {
   int new_file, old_file, new_file_size;
 
   /* Pointers to the base of the image of the two files. */
   caddr_t old_base, new_base;
 
+#if MAP_ANON == 0
+  int mmap_fd;
+#else
+# define mmap_fd -1
+#endif
+
   /* Pointers to the file, program and section headers for the old and new
    * files.
    */
-  Elf32_Ehdr *old_file_h, *new_file_h;
-  Elf32_Phdr *old_program_h, *new_program_h;
-  Elf32_Shdr *old_section_h, *new_section_h;
+  ElfW(Ehdr) *old_file_h, *new_file_h;
+  ElfW(Phdr) *old_program_h, *new_program_h;
+  ElfW(Shdr) *old_section_h, *new_section_h;
 
   /* Point to the section name table in the old file */
   char *old_section_names;
 
-  Elf32_Addr old_bss_addr, new_bss_addr;
-  Elf32_Word old_bss_size, new_data2_size;
-  Elf32_Off  new_data2_offset;
-  Elf32_Addr new_data2_addr;
-
-  int n, nn, old_bss_index, old_data_index, new_data2_index;
+  ElfW(Addr) old_bss_addr, new_bss_addr;
+  ElfW(Word) old_bss_size, new_data2_size;
+  ElfW(Off)  new_data2_offset;
+  ElfW(Addr) new_data2_addr;
+  ElfW(Off) old_bss_offset;
+  ElfW(Word) new_data2_incr, new_data2_shincr;
+
+  int n, nn;
+  int old_bss_index, old_sbss_index;
+  int old_data_index, new_data2_index;
+  int old_mdebug_index;
   struct stat stat_buf;
+  int old_file_size;
 
-  /* Open the old file & map it into the address space. */
+  /* Open the old file, allocate a buffer of the right size, and read
+   * in the file contents. */
 
   old_file = open (old_name, O_RDONLY);
 
@@ -508,90 +698,127 @@ unexec (new_name, old_name, data_start, 
   if (fstat (old_file, &stat_buf) == -1)
     fatal ("Can't fstat (%s): errno %d\n", old_name, errno);
 
-  old_base = mmap (0, stat_buf.st_size, PROT_READ, MAP_SHARED, old_file, 0);
+#if MAP_ANON == 0
+  mmap_fd = open ("/dev/zero", O_RDONLY);
+  if (mmap_fd < 0)
+    fatal ("Can't open /dev/zero for reading: errno %d\n", errno);
+#endif
 
-  if (old_base == (caddr_t) -1)
-    fatal ("Can't mmap (%s): errno %d\n", old_name, errno);
+  /* We cannot use malloc here because that may use sbrk.  If it does,
+     we'd dump our temporary buffers with Emacs, and we'd have to be
+     extra careful to use the correct value of sbrk(0) after
+     allocating all buffers in the code below, which we aren't.  */
+  old_file_size = stat_buf.st_size;
+  old_base = mmap (NULL, old_file_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, mmap_fd, 0);
+  if (old_base == MAP_FAILED)
+    fatal ("Can't allocate buffer for %s\n", old_name);
 
-#ifdef DEBUG
-  fprintf (stderr, "mmap (%s, %x) -> %x\n", old_name, stat_buf.st_size,
-	   old_base);
-#endif
+  if (read (old_file, old_base, stat_buf.st_size) != stat_buf.st_size)
+    fatal ("Didn't read all of %s: errno %d\n", old_name, errno);
 
   /* Get pointers to headers & section names */
 
-  old_file_h = (Elf32_Ehdr *) old_base;
-  old_program_h = (Elf32_Phdr *) ((byte *) old_base + old_file_h->e_phoff);
-  old_section_h = (Elf32_Shdr *) ((byte *) old_base + old_file_h->e_shoff);
+  old_file_h = (ElfW(Ehdr) *) old_base;
+  old_program_h = (ElfW(Phdr) *) ((byte *) old_base + old_file_h->e_phoff);
+  old_section_h = (ElfW(Shdr) *) ((byte *) old_base + old_file_h->e_shoff);
   old_section_names = (char *) old_base
     + OLD_SECTION_H (old_file_h->e_shstrndx).sh_offset;
 
+  /* Find the mdebug section, if any.  */
+
+  old_mdebug_index = find_section (".mdebug", old_section_names,
+				   old_name, old_file_h, old_section_h, 1);
+
   /* Find the old .bss section.  Figure out parameters of the new
    * data2 and bss sections.
    */
 
-  for (old_bss_index = 1; old_bss_index < (int) old_file_h->e_shnum;
-       old_bss_index++)
+  old_bss_index = find_section (".bss", old_section_names,
+				old_name, old_file_h, old_section_h, 0);
+
+  old_sbss_index = find_section (".sbss", old_section_names,
+				 old_name, old_file_h, old_section_h, 1);
+  if (old_sbss_index != -1)
+    if (OLD_SECTION_H (old_sbss_index).sh_type == SHT_PROGBITS)
+      old_sbss_index = -1;
+
+  if (old_sbss_index == -1)
     {
-#ifdef DEBUG
-      fprintf (stderr, "Looking for .bss - found %s\n",
-	       old_section_names + OLD_SECTION_H (old_bss_index).sh_name);
-#endif
-      if (!strcmp (old_section_names + OLD_SECTION_H (old_bss_index).sh_name,
-		   ELF_BSS_SECTION_NAME))
-	break;
+      old_bss_addr = OLD_SECTION_H (old_bss_index).sh_addr;
+      old_bss_size = OLD_SECTION_H (old_bss_index).sh_size;
+      old_bss_offset = OLD_SECTION_H (old_bss_index).sh_offset;
+      new_data2_index = old_bss_index;
+    }
+  else
+    {
+      old_bss_addr = OLD_SECTION_H (old_sbss_index).sh_addr;
+      old_bss_size = OLD_SECTION_H (old_bss_index).sh_size
+	+ OLD_SECTION_H (old_sbss_index).sh_size;
+      old_bss_offset = OLD_SECTION_H (old_sbss_index).sh_offset;
+      new_data2_index = old_sbss_index;
     }
-  if (old_bss_index == old_file_h->e_shnum)
-    fatal ("Can't find .bss in %s.\n", old_name, 0);
 
-  old_bss_addr = OLD_SECTION_H (old_bss_index).sh_addr;
-  old_bss_size = OLD_SECTION_H (old_bss_index).sh_size;
-#if defined(emacs) || !defined(DEBUG)
-  new_bss_addr = (Elf32_Addr) sbrk (0);
+  /* Find the old .data section.  Figure out parameters of
+     the new data2 and bss sections.  */
+
+  old_data_index = find_section (".data", old_section_names,
+				 old_name, old_file_h, old_section_h, 0);
+
+#if defined (emacs) || !defined (DEBUG)
+  new_bss_addr = (ElfW(Addr)) sbrk (0);
 #else
   new_bss_addr = old_bss_addr + old_bss_size + 0x1234;
 #endif
   new_data2_addr = old_bss_addr;
   new_data2_size = new_bss_addr - old_bss_addr;
-  new_data2_offset = OLD_SECTION_H (old_bss_index).sh_offset;
+  new_data2_offset = OLD_SECTION_H (old_data_index).sh_offset
+    + (new_data2_addr - OLD_SECTION_H (old_data_index).sh_addr);
+  /* This is the amount by which the sections following the bss sections
+     must be shifted in the image.  It can differ from new_data2_size if
+     the end of the old .data section (and thus the offset of the .bss
+     section) was unaligned.  */
+  new_data2_incr = new_data2_size + (new_data2_offset - old_bss_offset);
+  new_data2_shincr = round_up(new_data2_incr, old_program_h->p_align);
 
 #ifdef DEBUG
   fprintf (stderr, "old_bss_index %d\n", old_bss_index);
   fprintf (stderr, "old_bss_addr %x\n", old_bss_addr);
   fprintf (stderr, "old_bss_size %x\n", old_bss_size);
+  fprintf (stderr, "old_bss_offset %x\n", old_bss_offset);
   fprintf (stderr, "new_bss_addr %x\n", new_bss_addr);
   fprintf (stderr, "new_data2_addr %x\n", new_data2_addr);
   fprintf (stderr, "new_data2_size %x\n", new_data2_size);
   fprintf (stderr, "new_data2_offset %x\n", new_data2_offset);
+  fprintf (stderr, "new_data2_incr %x\n", new_data2_incr);
 #endif
 
   if ((unsigned) new_bss_addr < (unsigned) old_bss_addr + old_bss_size)
     fatal (".bss shrank when undumping???\n", 0, 0);
 
-  /* Set the output file to the right size and mmap it.  Set
-   * pointers to various interesting objects.  stat_buf still has
-   * old_file data.
+  /* Set the output file to the right size.  Allocate a buffer to hold
+   * the image of the new file.  Set pointers to various interesting
+   * objects.  stat_buf still has old_file data.
    */
 
   new_file = open (new_name, O_RDWR | O_CREAT, 0666);
   if (new_file < 0)
     fatal ("Can't creat (%s): errno %d\n", new_name, errno);
 
-  new_file_size = stat_buf.st_size + old_file_h->e_shentsize + new_data2_size;
+  new_file_size = stat_buf.st_size + old_file_h->e_shentsize + new_data2_shincr;
 
   if (ftruncate (new_file, new_file_size))
     fatal ("Can't ftruncate (%s): errno %d\n", new_name, errno);
 
-  new_base = mmap (0, new_file_size, PROT_READ | PROT_WRITE, MAP_SHARED,
-		   new_file, 0);
-
-  if (new_base == (caddr_t) -1)
-    fatal ("Can't mmap (%s): errno %d\n", new_name, errno);
-
-  new_file_h = (Elf32_Ehdr *) new_base;
-  new_program_h = (Elf32_Phdr *) ((byte *) new_base + old_file_h->e_phoff);
-  new_section_h = (Elf32_Shdr *)
-    ((byte *) new_base + old_file_h->e_shoff + new_data2_size);
+  new_base = mmap (NULL, new_file_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, mmap_fd, 0);
+  if (new_base == MAP_FAILED)
+    fatal ("Can't allocate buffer for %s\n", old_name);
+
+  new_file_h = (ElfW(Ehdr) *) new_base;
+  new_program_h = (ElfW(Phdr) *) ((byte *) new_base + old_file_h->e_phoff);
+  new_section_h = (ElfW(Shdr) *)
+    ((byte *) new_base + old_file_h->e_shoff + new_data2_shincr);
 
   /* Make our new file, program and section headers as copies of the
    * originals.
@@ -608,7 +835,7 @@ unexec (new_name, old_name, data_start, 
    * further away now.
    */
 
-  new_file_h->e_shoff += new_data2_size;
+  new_file_h->e_shoff += new_data2_shincr;
   new_file_h->e_shnum += 1;
 
 #ifdef DEBUG
@@ -629,12 +856,22 @@ unexec (new_name, old_name, data_start, 
   for (n = new_file_h->e_phnum - 1; n >= 0; n--)
     {
       /* Compute maximum of all requirements for alignment of section.  */
-      int alignment = (NEW_PROGRAM_H (n)).p_align;
+      ElfW(Word) alignment = (NEW_PROGRAM_H (n)).p_align;
       if ((OLD_SECTION_H (old_bss_index)).sh_addralign > alignment)
 	alignment = OLD_SECTION_H (old_bss_index).sh_addralign;
 
-      if (NEW_PROGRAM_H (n).p_vaddr + NEW_PROGRAM_H (n).p_filesz > old_bss_addr)
-	fatal ("Program segment above .bss in %s\n", old_name, 0);
+#ifdef __sgi
+	  /* According to r02kar@x4u2.desy.de (Karsten Kuenne)
+	     and oliva@gnu.org (Alexandre Oliva), on IRIX 5.2, we
+	     always get "Program segment above .bss" when dumping
+	     when the executable doesn't have an sbss section.  */
+      if (old_sbss_index != -1)
+#endif /* __sgi */
+      if (NEW_PROGRAM_H (n).p_vaddr + NEW_PROGRAM_H (n).p_filesz
+	  > (old_sbss_index == -1
+	     ? old_bss_addr
+	     : round_up (old_bss_addr, alignment)))
+	  fatal ("Program segment above .bss in %s\n", old_name, 0);
 
       if (NEW_PROGRAM_H (n).p_type == PT_LOAD
 	  && (round_up ((NEW_PROGRAM_H (n)).p_vaddr
@@ -646,10 +883,12 @@ unexec (new_name, old_name, data_start, 
   if (n < 0)
     fatal ("Couldn't find segment next to .bss in %s\n", old_name, 0);
 
-  NEW_PROGRAM_H (n).p_filesz += new_data2_size;
+  /* Make sure that the size includes any padding before the old .bss
+     section.  */
+  NEW_PROGRAM_H (n).p_filesz = new_bss_addr - NEW_PROGRAM_H (n).p_vaddr;
   NEW_PROGRAM_H (n).p_memsz = NEW_PROGRAM_H (n).p_filesz;
 
-#if 0 /* Maybe allow section after data2 - does this ever happen? */
+#ifdef IRIX5 /* allow section after data2 */
   for (n = new_file_h->e_phnum - 1; n >= 0; n--)
     {
       if (NEW_PROGRAM_H (n).p_vaddr
@@ -657,7 +896,7 @@ unexec (new_name, old_name, data_start, 
 	NEW_PROGRAM_H (n).p_vaddr += new_data2_size - old_bss_size;
 
       if (NEW_PROGRAM_H (n).p_offset >= new_data2_offset)
-	NEW_PROGRAM_H (n).p_offset += new_data2_size;
+	NEW_PROGRAM_H (n).p_offset += new_data2_incr;
     }
 #endif
 
@@ -675,18 +914,20 @@ unexec (new_name, old_name, data_start, 
   if (old_data_index == old_file_h->e_shnum)
     fatal ("Can't find .data in %s.\n", old_name, 0);
 
-  /* Walk through all section headers, insert the new data2 section right 
+  /* Walk through all section headers, insert the new data2 section right
      before the new bss section. */
   for (n = 1, nn = 1; n < (int) old_file_h->e_shnum; n++, nn++)
     {
       caddr_t src;
-      /* If it is bss section, insert the new data2 section before it. */
-      if (n == old_bss_index)
+      /* If it is (s)bss section, insert the new data2 section before it.  */
+      /* new_data2_index is the index of either old_sbss or old_bss, that was
+	 chosen as a section for new_data2.   */
+      if (n == new_data2_index)
 	{
 	  /* Steal the data section header for this data2 section. */
 	  memcpy (&NEW_SECTION_H (nn), &OLD_SECTION_H (old_data_index),
 		  new_file_h->e_shentsize);
-	  
+
 	  NEW_SECTION_H (nn).sh_addr = new_data2_addr;
 	  NEW_SECTION_H (nn).sh_offset = new_data2_offset;
 	  NEW_SECTION_H (nn).sh_size = new_data2_size;
@@ -696,73 +937,235 @@ unexec (new_name, old_name, data_start, 
 	  NEW_SECTION_H (nn).sh_addralign = OLD_SECTION_H (n).sh_addralign;
 
 	  /* Now copy over what we have in the memory now. */
-	  memcpy (NEW_SECTION_H (nn).sh_offset + new_base, 
-		  (caddr_t) OLD_SECTION_H (n).sh_addr, 
+	  memcpy (NEW_SECTION_H (nn).sh_offset + new_base,
+		  (caddr_t) OLD_SECTION_H (n).sh_addr,
 		  new_data2_size);
 	  nn++;
 	}
-      
-      memcpy (&NEW_SECTION_H (nn), &OLD_SECTION_H (n), 
+
+      memcpy (&NEW_SECTION_H (nn), &OLD_SECTION_H (n),
 	      old_file_h->e_shentsize);
-      
-      /* The new bss section's size is zero, and its file offset and virtual
-	 address should be off by NEW_DATA2_SIZE. */
-      if (n == old_bss_index)
+
+      if (n == old_bss_index
+	  /* The new bss and sbss section's size is zero, and its file offset
+	     and virtual address should be off by NEW_DATA2_SIZE.  */
+	  || n == old_sbss_index
+	  )
 	{
-	  /* NN should be `old_bss_index + 1' at this point. */
-	  NEW_SECTION_H (nn).sh_offset += new_data2_size;
-	  NEW_SECTION_H (nn).sh_addr += new_data2_size;
+	  /* NN should be `old_s?bss_index + 1' at this point. */
+	  NEW_SECTION_H (nn).sh_offset = new_data2_offset + new_data2_size;
+	  NEW_SECTION_H (nn).sh_addr = new_data2_addr + new_data2_size;
 	  /* Let the new bss section address alignment be the same as the
-	     section address alignment followed the old bss section, so 
+	     section address alignment followed the old bss section, so
 	     this section will be placed in exactly the same place. */
 	  NEW_SECTION_H (nn).sh_addralign = OLD_SECTION_H (nn).sh_addralign;
 	  NEW_SECTION_H (nn).sh_size = 0;
 	}
-      /* Any section that was original placed AFTER the bss section should now
-	 be off by NEW_DATA2_SIZE. */
-      else if (NEW_SECTION_H (nn).sh_offset >= new_data2_offset)
-	NEW_SECTION_H (nn).sh_offset += new_data2_size;
-      
+      else
+	{
+	  /* Any section that was original placed AFTER the bss
+	     section should now be off by NEW_DATA2_INCR.  If a
+	     section overlaps the .bss section, consider it to be
+	     placed after the .bss section.  Overlap can occur if the
+	     section just before .bss has less-strict alignment; this
+	     was observed between .symtab and .bss on Solaris 2.5.1
+	     (sparc) with GCC snapshot 960602.  */
+#ifdef SOLARIS_POWERPC
+	  /* On PPC Reference Platform running Solaris 2.5.1
+	     the plt section is also of type NOBI like the bss section.
+	     (not really stored) and therefore sections after the bss
+	     section start at the plt offset. The plt section is always
+	     the one just before the bss section.
+	     It would be better to put the new data section before
+	     the .plt section, or use libelf instead.
+	     Erik Deumens, deumens@qtp.ufl.edu.  */
+	  if (NEW_SECTION_H (nn).sh_offset
+	      >= OLD_SECTION_H (old_bss_index-1).sh_offset)
+	    NEW_SECTION_H (nn).sh_offset += new_data2_incr;
+#else
+	  if (NEW_SECTION_H (nn).sh_offset >= old_bss_offset)
+	    NEW_SECTION_H (nn).sh_offset += new_data2_incr;
+#endif
+	  /* Any section that was originally placed after the section
+	     header table should now be off by the size of one section
+	     header table entry.  */
+	  if (NEW_SECTION_H (nn).sh_offset > new_file_h->e_shoff)
+	    NEW_SECTION_H (nn).sh_offset += new_file_h->e_shentsize;
+	}
+
       /* If any section hdr refers to the section after the new .data
-	 section, make it refer to next one because we have inserted 
+	 section, make it refer to next one because we have inserted
 	 a new section in between.  */
-      
+
       PATCH_INDEX (NEW_SECTION_H (nn).sh_link);
       /* For symbol tables, info is a symbol table index,
 	 so don't change it.  */
       if (NEW_SECTION_H (nn).sh_type != SHT_SYMTAB
 	  && NEW_SECTION_H (nn).sh_type != SHT_DYNSYM)
 	PATCH_INDEX (NEW_SECTION_H (nn).sh_info);
+      
+      if (old_sbss_index != -1)
+	if (!strcmp (old_section_names + NEW_SECTION_H (nn).sh_name, ".sbss"))
+	  {
+	    NEW_SECTION_H (nn).sh_offset = 
+	      round_up (NEW_SECTION_H (nn).sh_offset,
+			NEW_SECTION_H (nn).sh_addralign);
+	    NEW_SECTION_H (nn).sh_type = SHT_PROGBITS;
+	  }
 
       /* Now, start to copy the content of sections.  */
       if (NEW_SECTION_H (nn).sh_type == SHT_NULL
 	  || NEW_SECTION_H (nn).sh_type == SHT_NOBITS)
 	continue;
-      
+
       /* Write out the sections. .data and .data1 (and data2, called
 	 ".data" in the strings table) get copied from the current process
 	 instead of the old file.  */
       if (!strcmp (old_section_names + NEW_SECTION_H (n).sh_name, ".data")
-#ifdef _nec_ews_svr4				/* hir, 1994.6.13 */
-	  || !strcmp ((old_section_names + NEW_SECTION_H(n).sh_name),
+	  || !strcmp ((old_section_names + NEW_SECTION_H (n).sh_name),
 		      ".sdata")
+	  || !strcmp ((old_section_names + NEW_SECTION_H (n).sh_name),
+		      ".lit4")
+	  || !strcmp ((old_section_names + NEW_SECTION_H (n).sh_name),
+		      ".lit8")
+	  /* The conditional bit below was in Oliva's original code
+	     (1999-08-25) and seems to have been dropped by mistake
+	     subsequently.  It prevents a crash at startup under X in
+	     `IRIX64 6.5 6.5.17m' with c_dev 7.3.1.3m.  It causes no
+	     trouble on the other ELF platforms I could test (Irix
+	     6.5.15m, Solaris 8, Debian Potato x86, Debian Woody
+	     SPARC); however, it's reported to cause crashes under
+	     some version of GNU/Linux.  It's not yet clear what's
+	     changed in that Irix version to cause the problem, or why
+	     the fix sometimes fails under GNU/Linux.  There's
+	     probably no good reason to have something Irix-specific
+	     here, but this will have to do for now.  IRIX6_5 is the
+	     most specific macro we have to test.  -- fx 2002-10-01  */
+#ifdef IRIX6_5
+	  || !strcmp ((old_section_names + NEW_SECTION_H (n).sh_name),
+		      ".got")
 #endif
 	  || !strcmp ((old_section_names + NEW_SECTION_H (n).sh_name),
-		      ".data1"))
+		      ".sdata1")
+	  || !strcmp ((old_section_names + NEW_SECTION_H (n).sh_name),
+		      ".data1")
+	  || !strcmp ((old_section_names + NEW_SECTION_H (n).sh_name),
+		      ".sbss"))
 	src = (caddr_t) OLD_SECTION_H (n).sh_addr;
       else
 	src = old_base + OLD_SECTION_H (n).sh_offset;
-      
+
       memcpy (NEW_SECTION_H (nn).sh_offset + new_base, src,
 	      NEW_SECTION_H (nn).sh_size);
 
+#if defined(__alpha__) && !defined(__NetBSD__)
+      /* Update Alpha COFF symbol table: */
+      if (strcmp (old_section_names + OLD_SECTION_H (n).sh_name, ".mdebug")
+	  == 0)
+	{
+	  pHDRR symhdr = (pHDRR) (NEW_SECTION_H (nn).sh_offset + new_base);
+
+	  symhdr->cbLineOffset += new_data2_size;
+	  symhdr->cbDnOffset += new_data2_size;
+	  symhdr->cbPdOffset += new_data2_size;
+	  symhdr->cbSymOffset += new_data2_size;
+	  symhdr->cbOptOffset += new_data2_size;
+	  symhdr->cbAuxOffset += new_data2_size;
+	  symhdr->cbSsOffset += new_data2_size;
+	  symhdr->cbSsExtOffset += new_data2_size;
+	  symhdr->cbFdOffset += new_data2_size;
+	  symhdr->cbRfdOffset += new_data2_size;
+	  symhdr->cbExtOffset += new_data2_size;
+	}
+#endif /* __alpha__ */
+
+#if defined (__sony_news) && defined (_SYSTYPE_SYSV)
+      if (NEW_SECTION_H (nn).sh_type == SHT_MIPS_DEBUG
+	  && old_mdebug_index != -1) 
+        {
+	  int diff = NEW_SECTION_H(nn).sh_offset 
+	 	- OLD_SECTION_H(old_mdebug_index).sh_offset;
+	  HDRR *phdr = (HDRR *)(NEW_SECTION_H (nn).sh_offset + new_base);
+
+	  if (diff)
+	    {
+	      phdr->cbLineOffset += diff;
+	      phdr->cbDnOffset   += diff;
+	      phdr->cbPdOffset   += diff;
+	      phdr->cbSymOffset  += diff;
+	      phdr->cbOptOffset  += diff;
+	      phdr->cbAuxOffset  += diff;
+	      phdr->cbSsOffset   += diff;
+	      phdr->cbSsExtOffset += diff;
+	      phdr->cbFdOffset   += diff;
+	      phdr->cbRfdOffset  += diff;
+	      phdr->cbExtOffset  += diff;
+	    }
+	}
+#endif /* __sony_news && _SYSTYPE_SYSV */
+
+#if __sgi
+      /* Adjust  the HDRR offsets in .mdebug and copy the 
+	 line data if it's in its usual 'hole' in the object.
+	 Makes the new file debuggable with dbx.
+	 patches up two problems: the absolute file offsets
+	 in the HDRR record of .mdebug (see /usr/include/syms.h), and
+	 the ld bug that gets the line table in a hole in the
+	 elf file rather than in the .mdebug section proper.
+	 David Anderson. davea@sgi.com  Jan 16,1994.  */
+      if (n == old_mdebug_index)
+	{
+#define MDEBUGADJUST(__ct,__fileaddr)		\
+  if (n_phdrr->__ct > 0)			\
+    {						\
+      n_phdrr->__fileaddr += movement;		\
+    }
+
+	  HDRR * o_phdrr = (HDRR *)((byte *)old_base + OLD_SECTION_H (n).sh_offset);
+	  HDRR * n_phdrr = (HDRR *)((byte *)new_base + NEW_SECTION_H (nn).sh_offset);
+	  unsigned movement = new_data2_size;
+
+	  MDEBUGADJUST (idnMax, cbDnOffset);
+	  MDEBUGADJUST (ipdMax, cbPdOffset);
+	  MDEBUGADJUST (isymMax, cbSymOffset);
+	  MDEBUGADJUST (ioptMax, cbOptOffset);
+	  MDEBUGADJUST (iauxMax, cbAuxOffset);
+	  MDEBUGADJUST (issMax, cbSsOffset);
+	  MDEBUGADJUST (issExtMax, cbSsExtOffset);
+	  MDEBUGADJUST (ifdMax, cbFdOffset);
+	  MDEBUGADJUST (crfd, cbRfdOffset);
+	  MDEBUGADJUST (iextMax, cbExtOffset);
+	  /* The Line Section, being possible off in a hole of the object,
+	     requires special handling.  */
+	  if (n_phdrr->cbLine > 0)
+	    {
+	      if (o_phdrr->cbLineOffset > (OLD_SECTION_H (n).sh_offset
+					   + OLD_SECTION_H (n).sh_size))
+		{
+		  /* line data is in a hole in elf. do special copy and adjust
+		     for this ld mistake.
+		     */
+		  n_phdrr->cbLineOffset += movement;
+
+		  memcpy (n_phdrr->cbLineOffset + new_base,
+			  o_phdrr->cbLineOffset + old_base, n_phdrr->cbLine);
+		}
+	      else
+		{
+		  /* somehow line data is in .mdebug as it is supposed to be.  */
+		  MDEBUGADJUST (cbLine, cbLineOffset);
+		}
+	    }
+	}
+#endif /* __sgi */
+
       /* If it is the symbol table, its st_shndx field needs to be patched.  */
       if (NEW_SECTION_H (nn).sh_type == SHT_SYMTAB
 	  || NEW_SECTION_H (nn).sh_type == SHT_DYNSYM)
 	{
-	  Elf32_Shdr *spt = &NEW_SECTION_H (nn);
+	  ElfW(Shdr) *spt = &NEW_SECTION_H (nn);
 	  unsigned int num = spt->sh_size / spt->sh_entsize;
-	  Elf32_Sym * sym = (Elf32_Sym *) (NEW_SECTION_H (nn).sh_offset + 
+	  ElfW(Sym) * sym = (ElfW(Sym) *) (NEW_SECTION_H (nn).sh_offset +
 					   new_base);
 	  for (; num--; sym++)
 	    {
@@ -770,7 +1173,7 @@ unexec (new_name, old_name, data_start, 
 		  || (sym->st_shndx == SHN_ABS)
 		  || (sym->st_shndx == SHN_COMMON))
 		continue;
-	
+
 	      PATCH_INDEX (sym->st_shndx);
 	    }
 	}
@@ -780,30 +1183,101 @@ unexec (new_name, old_name, data_start, 
   for (n = new_file_h->e_shnum - 1; n; n--)
     {
       byte *symnames;
-      Elf32_Sym *symp, *symendp;
+      ElfW(Sym) *symp, *symendp;
 
       if (NEW_SECTION_H (n).sh_type != SHT_DYNSYM
 	  && NEW_SECTION_H (n).sh_type != SHT_SYMTAB)
 	continue;
 
-      symnames = NEW_SECTION_H (NEW_SECTION_H (n).sh_link).sh_offset + new_base;
-      symp = (Elf32_Sym *) (NEW_SECTION_H (n).sh_offset + new_base);
-      symendp = (Elf32_Sym *) ((byte *)symp + NEW_SECTION_H (n).sh_size);
+      symnames = ((byte *) new_base
+		  + NEW_SECTION_H (NEW_SECTION_H (n).sh_link).sh_offset);
+      symp = (ElfW(Sym) *) (NEW_SECTION_H (n).sh_offset + new_base);
+      symendp = (ElfW(Sym) *) ((byte *)symp + NEW_SECTION_H (n).sh_size);
 
       for (; symp < symendp; symp ++)
 	if (strcmp ((char *) (symnames + symp->st_name), "_end") == 0
-	    || strcmp ((char *) (symnames + symp->st_name), "_edata") == 0)
+	    || strcmp ((char *) (symnames + symp->st_name), "end") == 0
+	    || strcmp ((char *) (symnames + symp->st_name), "_edata") == 0
+	    || strcmp ((char *) (symnames + symp->st_name), "edata") == 0)
 	  memcpy (&symp->st_value, &new_bss_addr, sizeof (new_bss_addr));
     }
 
-  /* Close the files and make the new file executable.  */
+  /* This loop seeks out relocation sections for the data section, so
+     that it can undo relocations performed by the runtime linker.  */
+  for (n = new_file_h->e_shnum - 1; n; n--)
+    {
+      ElfW(Shdr) section = NEW_SECTION_H (n);
+      switch (section.sh_type) {
+      default:
+	break;
+      case SHT_REL:
+      case SHT_RELA:
+	/* This code handles two different size structs, but there should
+	   be no harm in that provided that r_offset is always the first
+	   member.  */
+	nn = section.sh_info;
+	if (!strcmp (old_section_names + NEW_SECTION_H (nn).sh_name, ".data")
+	    || !strcmp ((old_section_names + NEW_SECTION_H (nn).sh_name),
+			".sdata")
+	    || !strcmp ((old_section_names + NEW_SECTION_H (nn).sh_name),
+			".lit4")
+	    || !strcmp ((old_section_names + NEW_SECTION_H (nn).sh_name),
+			".lit8")
+#ifdef IRIX6_5			/* see above */
+	    || !strcmp ((old_section_names + NEW_SECTION_H (nn).sh_name),
+			".got")
+#endif
+	    || !strcmp ((old_section_names + NEW_SECTION_H (nn).sh_name),
+			".sdata1")
+	    || !strcmp ((old_section_names + NEW_SECTION_H (nn).sh_name),
+			".data1"))
+	  {
+	    ElfW(Addr) offset = NEW_SECTION_H (nn).sh_addr -
+	      NEW_SECTION_H (nn).sh_offset;
+	    caddr_t reloc = old_base + section.sh_offset, end;
+	    for (end = reloc + section.sh_size; reloc < end;
+		 reloc += section.sh_entsize)
+	      {
+		ElfW(Addr) addr = ((ElfW(Rel) *) reloc)->r_offset - offset;
+#ifdef __alpha__
+		/* The Alpha ELF binutils currently have a bug that
+		   sometimes results in relocs that contain all
+		   zeroes.  Work around this for now...  */
+		if (((ElfW(Rel) *) reloc)->r_offset == 0)
+		    continue;
+#endif
+		memcpy (new_base + addr, old_base + addr, sizeof(ElfW(Addr)));
+	      }
+	  }
+	break;
+      }
+    }
 
-  if (close (old_file))
-    fatal ("Can't close (%s): errno %d\n", old_name, errno);
+  /* Write out new_file, close it, and free the buffer containing its
+   * contents */
+
+  if (write (new_file, new_base, new_file_size) != new_file_size)
+    fatal ("Didn't write %d bytes to %s: errno %d\n", 
+	   new_file_size, new_base, errno);
 
   if (close (new_file))
     fatal ("Can't close (%s): errno %d\n", new_name, errno);
 
+  munmap (new_base, new_file_size);
+
+  /* Close old_file, and free the corresponding buffer */
+
+#if MAP_ANON == 0
+  close (mmap_fd);
+#endif
+
+  if (close (old_file))
+    fatal ("Can't close (%s): errno %d\n", old_name, errno);
+
+  munmap (old_base, old_file_size);
+
+  /* Make the new file executable */
+
   if (stat (new_name, &stat_buf) == -1)
     fatal ("Can't stat (%s): errno %d\n", new_name, errno);
 
